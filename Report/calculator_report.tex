\documentclass{report}

% Sections and chapters
%\usepackage{blindtext}
\usepackage[utf8]{inputenc}

% For links
\usepackage[hidelinks]{hyperref}
\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

% Cause C++ code
\usepackage{listings}
\usepackage{lstautogobble}	% For indentation in code (lstlisting)
\usepackage{xcolor}
\usepackage{textcomp}	% Said it needed this for the code
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
%\definecolor{darkgreen}{rgb}{0.0, 0.9, 0.0}
\lstset{
	autogobble=true,	% Added
	backgroundcolor=\color{lbcolor},
	tabsize=4,    
	%   rulecolor=,
	language=[GNU]C++,
	basicstyle=\scriptsize,
	upquote=true,
%	aboveskip={1.5\baselineskip},
	aboveskip=\medskipamount,	% Changed
	columns=fixed,
	showstringspaces=false,
	extendedchars=false,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	frame=single,
	numbers=left,
	showtabs=false,
	showspaces=false,
	showstringspaces=false,
	identifierstyle=\ttfamily,
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.0,0.5,0.0},		%% Comment color
	stringstyle=\color[rgb]{0.627,0.126,0.941},
	numberstyle=\color[rgb]{0.205, 0.142, 0.73}
	%\lstdefinestyle{C++}{language=C++,style=numbers}â€™.
}


%\lstset{
%	backgroundcolor=\color{lbcolor},
%	tabsize=4,
%	language=C++,
%	captionpos=b,
%	tabsize=3,
%	frame=lines,
%	numbers=left,
%	numberstyle=\tiny,
%	numbersep=5pt,
%	breaklines=true,
%	showstringspaces=false,
%	basicstyle=\footnotesize,
%	%  identifierstyle=\color{magenta},
%	keywordstyle=\color[rgb]{0,0,1},
%	commentstyle=\color{darkgreen},
%	stringstyle=\color{red}
%}


\begin{document}
	% Make title
	\title{Object Oriented Programming Languages\\C++ Lecture Notes}
	\date{\today}
	\author{Paul Knutson}
	\maketitle
	\clearpage
	\tableofcontents{}
	\clearpage
	
	
	\chapter{Lecture 1 - Introduction}
	
		%	Text before \dots
		%	\begin{lstlisting}
		%	for (int i=0; i<iterations;i++)
		%	{
		%	do something
		%	}
		%	\end{lstlisting}
		%	Text after it \dots
		
		
		
		\section{Intro?}
			The most basic Hello World program in C++ \\
			
			\begin{minipage}{\linewidth}
				Prints out "Hello World!"
				\begin{lstlisting}
					#include <iostream>
					
					int main()
					{
						std::cout << "Hello world!" << std::endl;
						return 0;
					}
				\end{lstlisting}
			\end{minipage}
		% End of section
		
		
		\section{Data Type Variables}
			Variable identifiers, or variable names, can consist of upper and lower case letters, numbers, and underscores.
			They can not start with a number. \\
			
			\subsection{Data types}
				Different data types in C++ \\
				
				\begin{minipage}{\linewidth}
					\begin{lstlisting}
						//Type				Description
						bool				true / false
						char				Character / byte
						unsigned char		Character / byte
						signed char			Character
						int					Whole number
						unsigned int		Natural number
						signed int			Whole number
						short int			Whole number
						unsigned short int	Natural number
						signed short int	Whole number
						long int			Large whole number
						unsigned long int	Large natural number
						signed long int		Large whole number
						float				Floating point value
						double				Larger floating point
						long double			Largest floating point
					\end{lstlisting}
				\end{minipage}
				\\ \\
				
				\begin{minipage}{\linewidth}
					The sized of different data types in C++
					\begin{lstlisting}
						#define SHRT_MIN (-32768)			//minimum (signed) short value
						#define SHRT_MAX 32767				//maximum (signed) short value
						#define USHRT_MAX 0xffff        	//maximum unsigned short value
						#define INT_MIN (-2147483647 -1)	//minimum (signed) int value
						#define INT_MAX 2147483647			//maximum (signed) int value
						#define UINT_MAX 0xffffffff    		//maximum unsigned int value
						#define LONG_MIN (-2147483647L -1)	//minimum (signed) long value
						#define LONG_MAX 2147483647L		//maximum (signed) long value
						#define ULONG_MAX 0xffffffffUL		//maximum unsigned long value
					\end{lstlisting}
				\end{minipage}
				\\ \\
			% End of subsection
			
			
			\subsection{Declaration}
				The process of declaring variables in C++ \\
				
				\begin{minipage}{\linewidth}
					Without initial value:
					\begin{lstlisting}
						int		iANumber;
						float	fAFloat
						char	cAChar;
					\end{lstlisting}
				\end{minipage}
				\\ \\
				
				\begin{minipage}{\linewidth}
					With initial value:
					\begin{lstlisting}
						int		iANumber	= 3;
						float	fAFloat		= 3.14;
						char	cAChar;		= 'a';
					\end{lstlisting}
				\end{minipage}
				\\ \\
			% End of subsection
			
			
			\subsection{Scope}
				The scope of variables in C++ \\
				
				\begin{minipage}{\linewidth}
					Global Variable
					\begin{lstlisting}
						#include <iostream>
						
						int iNumber;
						
						int main (void)
						{
							//...
						}
					\end{lstlisting}
				\end{minipage}
				\\ \\
				
				\begin{minipage}{\linewidth}
					Local variable (1):
					\begin{lstlisting}
						#include <iostream>
						
						int main (void)
						{
							int iNumber;
							//...
						}
					\end{lstlisting}
				\end{minipage}
				\\ \\
				
				\begin{minipage}{\linewidth}
					Local variable (2):
					\begin{lstlisting}
						void someFunc (void)
						{
						CallSomeFunc();
						CallSomeOtherFunc();
						char c;
						cin << c;
						//...
						}
					\end{lstlisting}
				\end{minipage}
				\\ \\
				
				\begin{minipage}{\linewidth}
					Variable scope example:
					\begin{lstlisting}
						#include <iostream>
						
						int iI = 11;	// Version 1
						
						void Func(void);
						
						int main(void)
						{
							int iI = 21;	// Version 2
							{
								int iI = 31;	// Version 3
								std::cout << "(1) iT = " << iI << std::endl;
							}
							std::cout << "(2) iT = " << iI << std::endl;
							Func()
						}
						
						void Func(void)
						{
							std::cout << "(3) iT = " << iI << std::endl;
						}
					\end{lstlisting}
				\end{minipage}
				
				\begin{minipage}{\linewidth}
					Program output:
					\begin{lstlisting}
						(1) iI = 31
						(1) iI = 21
						(1) iI = 11
					\end{lstlisting}
				\end{minipage}
				\\ \\
			% End of subsection
			
			
			\subsection{Variable modifiers}
				Use of different variable modifiers in C++ \\
				
				\begin{minipage}{\linewidth}
					Constant (const): \\
					Constants cannot be changed later.
					These are used for constant values like pi, the gravitational constant etc.
					\begin{lstlisting}
						const int nI 		= 1+;
						const char c 		= '\n';
						const float f		= 3e-02;
						const double pi		= 3.141592;
						const double twoPi	= 2.0 * pi;
					\end{lstlisting} 
				\end{minipage}
				\\ \\
				
				\begin{minipage}{\linewidth}
					Static (static): \\
					When using a regular value as input in a normal function, the variable will be copied into the function.
					This requires more memory, but allow for editing the copy, rather than the variable itself.
					When passing a static variable into a function, the function will access the static variable itself, and not make a copy of it.
					\begin{lstlisting}
						const int nI 		= 1+;
						const char c 		= '\n';
						const float f		= 3e-02;
						const double pi		= 3.141592;
						const double twoPi	= 2.0 * pi;
					\end{lstlisting} 
				\end{minipage}
				\\ \\
			% End of subsection
			
			
			\subsection{Task 1}
				Task 1 - Data variables \\
				The task is as follows (the tasks are roughly translated from Norwegian):
				
				\begin{itemize}
					\item You are to make a program to calculate the area of a circle,
						based on pi rounded off to a certain decimals amount of decimals.
					\item Make a global constant named "pi", with the value 3.14.
					\item In the main() function, you will read in the radius of the circle with cin (std::cin),
						and to different functions will calculate the area of the circle, using different methods.
					\begin{itemize}
						\item area1() should use the global constant "pi".
						\item area2() should use a local constant, also named "pi", with the value 3.14159.
					\end{itemize}
					\item Write out both results in main().
				\end{itemize}
				
				
				\begin{minipage}{\linewidth}
					The solution code for this task:
					\begin{lstlisting}
						#include "stdafx.h"	// When using VS
						#include <iostream>
						
						float pi = 3.14;	// Global const
						
						float area1(float radius);
						float area2(float radius);
						
						
						int main()
						{
							// Declare and get input value for radius
							float radius;
							std::cout << "Input the radius of the circle: ";
							std::cin >> radius;
							
							// Print out area based on global const
							std::cout << "Result from area1():\t";
							std::cout << area1(radius) << std::endl;
							
							// Print out area based on local const
							std::cout << "Result from area2():\t";
							std::cout << area2(radius) << std::endl;
							return 0;
						}
						
						float area1(float radius)
						{
							return (2 * pi * radius);
						}
						
						float area2(float radius)
						{
							float const pi = 3.14159;	// Local const
							return (2 * pi * radius);
						}
					\end{lstlisting}
				\end{minipage}
				\\ \\
		% End of subsection
		
		
		
		\section{Enumerated Data Types}
			Enumerated types allows you to specify the values the variable can have. \\
			
			\begin{minipage}{\linewidth}
				This means the following enum:
				\begin{lstlisting}
					enum DayNumber {
					Monday, 	Tuesday,
					Wednesday, 	Thursday,
					Friday, 	Saturday,
					Sunday
					}
				\end{lstlisting}
			\end{minipage}
			
			\begin{minipage}{\linewidth}
				is practically equivalent with:
				\begin{lstlisting}
					const int Monday	= 0;
					const int Tuesday	= 1;
					const int Wednesday	= 2;
					const int Thursday	= 3;
					const int Friday	= 4;
					const int Saturday	= 5;
					const int Sunday	= 6;
				\end{lstlisting}
			\end{minipage}
			\\ \\
			
			\begin{minipage}{\linewidth}
			Mixing with ints:
			\begin{lstlisting}
				enum Color {RED, GREEN, BLUE};
				Color c = RED;
				int i 	= 0;
				i 		= c;
				c 		= static_cast<Color>(i);
				i 		= RED;
				c 		= static_cast<Color>(3);
			\end{lstlisting}
			\end{minipage}
			\\ \\
			
			\begin{minipage}{\linewidth}
			Control with values:
			\begin{lstlisting}
				enum Color {RED = 1, GREEN = 2, BLUE = 4};
			\end{lstlisting}
			\end{minipage}
			\\ \\
		% End of section
		
		
		
		\section{Arrays}
			Arrays allow for storage of multiple values of the same data type. \\
			
			\begin{minipage}{\linewidth}
				Declaration of some arrays:
				\begin{lstlisting}
					char	alphabet[26];
					int 	vector[10];
				\end{lstlisting}
			\end{minipage}
			\\ \\
			
			\begin{minipage}{\linewidth}
				Accessing/indexing:
				\begin{lstlisting}
					alphabet[0] 	= 'A';
					alphabet[25]	= 'Z';
				\end{lstlisting}
			\end{minipage}
			\\ \\
			
			\begin{minipage}{\linewidth}
				Accessing/indexing:
				\begin{lstlisting}
					int vector[10] 	= {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
					char alphabet 	= "ABCDEFGHIJKLMNOPQRSTUVWXYZ";	// Special for chars.
				\end{lstlisting}
			\end{minipage}
			\\ \\
			
			\begin{minipage}{\linewidth}
				Arrays in multiple dimentions:
				\begin{lstlisting}
					int matrix[2][3];
					matrix =
					{
						{0, 1, 2},
						{3, 4, 5}
					}
					// matrix[0][1] has the value of 4
				\end{lstlisting}
			\end{minipage}
			\\ \\
			
			
			\subsection{Task 2}
				Task 2 - Arrays \\
				The task is as follows (roughly translated from Norwegian):
				
				\begin{itemize}
					\item Create a program that writes out whether the values in the small multiplication table are even or odd:
					\begin{itemize}
						\item Make an enumerated type "NumberType" with the values "even" and "odd".
						\item Make a 2D array of type NumberType, with 10*10 elements.
						\item Calculate the values in the small multiplication table, and notice whether the numebr is odd or even.
						\item Write out the result.
					\end{itemize}
				\end{itemize}
				
				
				\begin{minipage}{\linewidth}
					The solution code for this task:
					\begin{lstlisting}
						#include "stdafx.h"	// When using VS
						#include <iostream>
						
						enum class numberType { even = 0, odd = 1 };
						
						void numberTypeMatrixPrinter(numberType products[10][10]);
						
						
						int main()
						{
							// Make the enum matrix
							numberType numberTypeMatrix[10][10];
							for (size_t i = 0; i < 10; i++)	// loop through matrix
							{
								for (size_t j = 0; j < 10; j++)
								{
									if ((i+1)*(j+1) % 2 == 0)	// if even
									{
										numberTypeMatrix[i][j] = numberType::even;
									}
									else	// else is odd
									{
										numberTypeMatrix[i][j] = numberType::odd;
									}
								}
							}
							// Print out the numberType (odd/even) results
							numberTypeMatrixPrinter(numberTypeMatrix);
							return 0;
						}
						
						void numberTypeMatrixPrinter(numberType numberTypeMatrix[10][10])
						{
							for (size_t i = 0; i < 10; i++)
							{
								std::cout << i+1 << '\t';
								for (size_t j = 0; j < 10; j++)	// loop through matrix
								{
									if (j <= i)
									{
										if (static_cast<int>(numberTypeMatrix[i][j]) == 0)
										{	// if even
											std::cout << "even\t";
										}
										else
										{	// else odd
											std::cout << "odd\t";
										}
									}
									else
									{
										break;
									}
								}
								std::cout << std::endl;
							}
							std::cout << "\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10" << std::endl;
						}
					\end{lstlisting}
				\end{minipage}
				\\ \\
			% End of subsection
		
		
		
		\section{Structures}
			Organisation of multiple elements of different type \\
			
			\begin{minipage}{\linewidth}
				\begin{lstlisting}
					struct Ship {
						char pszName[20];	// Name of ship
						int iPosX;			// Ship position
						int iPosY;
						int iVelX;			// Ship velocity
						int iVelY;
					};
				\end{lstlisting}
			\end{minipage}
			\\ \\
			
			\begin{minipage}{\linewidth}
				Deklarations
				\begin{lstlisting}
					Ship OneShpi;
					Ship OneShip = {"HMS YourMom", 100, 120, 10, 0};
				\end{lstlisting}
			\end{minipage}
			\\ \\
			
			\begin{minipage}{\linewidth}
				Accessing
				\begin{lstlisting}
					std::cout << "Name		: " << OneShip.pszName << std::endl;
					std::cout << "Position	: " << OneShip.iPosX << ","
												<< OneShip.iPosY << endl;
				\end{lstlisting}
			\end{minipage}
			\\ \\
			
			
			\subsection{Task 3}
				Task 3 - Structs \\
				
				\begin{itemize}
					\item Make a program which registers sex (char), age (int), and height (float).
					\item This information should be read from the keyboard and stored in a struct.
					\item Use an enumerated type to represent sex (M or K).
					\item Write out the information which was previously read in.
				\end{itemize}
				
				
				\begin{minipage}{\linewidth}
					The solution code for this task:
					\begin{lstlisting}
						#include "stdafx.h"	// When using VS
						#include <iostream>
						
						enum sex {
							M,
							F
						};
						
						struct person {
							sex		sex;
							int		age;
							float	height;
						};
						
						
						int main()
						{
							person me;
							
							char inputSex;
							std::cout << "Sex: M/F\t";
							std::cin >> inputSex;
							switch (inputSex)
							{
								case 'M'	: me.sex = M; break;
								case 'm'	: me.sex = M; break;
								case 'F'	: me.sex = F; break;
								case 'f'	: me.sex = F; break;
								default		: "Dafuq!?";  break;
							}
							
							std::cout << "Age: [int]\t";
							std::cin >> me.age;
							
							std::cout << "height: [float]\t";
							std::cin >> me.height;
							
							std::cout << "Sex:\t";
							if (me.sex == M)
							{
								std::cout << "M (male)" << std::endl;
							}
							else if (me.sex == F)
							{
								std::cout << "F (female)" << std::endl;
							}
							else
							{
								std::cout << "The internets won't like you :|" << std::endl;
							}
							std::cout << "Age:\t"	<< me.age		<< std::endl;;
							std::cout << "Height:\t"<< me.height	<< std::endl;
							
							return 0;
						}
					\end{lstlisting}
				\end{minipage}
				\\ \\
		% End of section
		
		
		
		\section{Pointers and Variables}
			\subsection{Pointers}
				Pointer value = address to memory location of another variable. \\
				Pointer: Reflects the type of value location. \\
				
				\begin{minipage}{\linewidth}
					basicType *name;
					\begin{lstlisting}
						int		*pInt;		// Pointer to an int
						int		**ppInt;	// Pointer to a pointer to an int
						char	*pChar[10];	// An array of 7 pointers to char;
						char	(*pChar)[10]
					\end{lstlisting}
				\end{minipage}
				\\ \\
				
				\begin{minipage}{\linewidth}
					Examples of using pointers:
					\begin{lstlisting}
					int	iAnInt = 10;
					int	*pInt;
					pInt = &iAnInt;
					std::cout << iAnInt << " = " << *pInt << std::endl;
					\end{lstlisting}
				\end{minipage}
				\\ \\
			% End of subsection
			
			
			\subsection{Task 4}
				Task 4 - Pointers \\
				
				\begin{itemize}
					\item Pointers are conceptually complex, so we will hav e a simple task on this subject.
					\item Create a variable "num", with the value 42.
					\item Create a pointer "p", and let it point to num.
					\item Write out the value of num using p.
					\item Increment num by 1 via p, and write it out using num.
					\item Reduce of num by 1 via num, and write it out using p.
					\item Write out p. (p does not have the value 42, but the address to 42 (num)).
				\end{itemize}
				
				
				\begin{minipage}{\linewidth}
					The solution code for this task:
					\begin{lstlisting}
						#include "stdafx.h"	// When using VS
						#include <iostream>
						
						
						int main()
						{
							int num = 42;
							int *p;
							
							p = &num;	// p points to the reference (address) of num
							std::cout << *p << std::endl;	// Points to num
							
							++*p;	// Does not like *p++; for whatever reason
							std::cout << num << std::endl;
							
							num--;	// Or --num;
							std::cout << *p << std::endl;	// Points to num
							std::cout << p << std::endl;	// Points to address of num
							return 0;
						}
					\end{lstlisting}
				\end{minipage}
				\\ \\
			% End of subsection
			
			
			\subsection{References}
				Alias for a variable. \\
				
				\begin{minipage}{\linewidth}
					Example:
					\begin{lstlisting}
						int		value = 10;
						int		&refToValue = value;
						std::cout 	<< "refToValue: " 	<< refToValue
									<< ", value: " 		<< value << std::endl;
						// Output:
						// refToValue: 10, value: 10
					\end{lstlisting}
				\end{minipage}
				\\ \\
				% Later: references with parameters to function shell
			% End of subsection
			\subsection{Void}
				The type void \\
				
				\begin{minipage}{\linewidth}
					Use I:
					\begin{lstlisting}
						void SayHello(void)
						{
							std::cout << "Hey there!" << std::endl;
						}
					\end{lstlisting}
				\end{minipage}
				\\ \\
				
				\begin{minipage}{\linewidth}
					Use II - pointers:
					\begin{lstlisting}
						void 	*pPtr;
						char	lpszName[10] = "0123456789":
						int 	iI = 10;
						
						pPtr	= lpszName;
						std::cout << (char*) pPtr << std::endl;
						pPtr	= &iI;
						std::cout << *((int*) pPtr) << std::endl;
					\end{lstlisting}
				\end{minipage}
				\\ \\
			% End of subsection
		% End of section
		
		
		
		\section{Operator}
			Different types of operatios in C++ \\
			
			\begin{minipage}{\linewidth}
				\begin{lstlisting}
					() [] -> .							\\
					! ~++ -- + - * \& (cast) sizeof		\\
					* / \%								\\
					+ -									\\
					<< >>								\\
					<<= >>=								\\
					== !=								\\
					\&									\\
					\^									\\
					|									\\
					\&\&								\\
					||									\\
					?:									\\
					= += -= *= /= \%= \&= |= \^=		\\
					,									\\
				\end{lstlisting}
			\end{minipage}
			\\ \\
			
			
			\subsection{Arithmetic Operators}
				Some of the arithmetic operators in C++ \\
				
				\begin{minipage}{\linewidth}
					\begin{lstlisting}
						x = +42;
						x  =-42;
						
						int		y;
						int		x = 5;
						int		z = 0;
						x++;
						y = 100 + x;	// y == 106
						y = --z;		// y == z == -1
						y = z++;		// y == -1, z == 0
						
						x = 103 + a;
						x = 100 % 45;
					\end{lstlisting}
				\end{minipage}
				\\ \\
			% End of subsection
			
			\subsection{Bitwise Operators}
				Operators used for bits and bytes \\
				\begin{minipage}{\linewidth}
					\begin{lstlisting}
						unsigned char byte1 = 128;	// 1000 0000
						unsigned char byte2 = 64;	// 0100 0000
						unsigned char byte3;
						
						byte3 = ~byte1;			// 0111 1111	Reverses?
						byte3 = ~~byte1			// 1000 0000	Double reverse
						byte3 = byte1 & byte2;	// Bit-wise AND : 0
						byte3 = byte1 | byte2;	// Bit-wise OR 	: 1100 0000
						byte3 = byte1 >> 2;		// 0010 0000	Move bit? i.e. divide by 2?
						byte3 = byte2 << 1;		// 1000 0000	Multiply by 2? 
						byte3 = byte1 ^byte2;	// Exclusive OR : 1100 0000
						
						signed char b = 138;	// 1000 1010
						signed char br;
						br = b >> 2;			// 1110 0010
					\end{lstlisting}
				\end{minipage}
				\\ \\
				
			
				\subsubsection{Different ways of accessing unsigned chars}
					\begin{minipage}{\linewidth}
						\begin{lstlisting}
							#include "stdafx.h"	// Because Visual Studio
							#include <iostream>
							#include <bitset>	// For making char into a bitset
							
							
							int main()
							{
								/// Making the numbers
								unsigned char byte1 = 128;
								unsigned char byte2 = 64;
								std::cout 
								<< "The char values in question are 128 and 64 respectively.\n"
								<< std::endl;
								
								
								/// Print out as a char
								std::cout << "Print out as a char" << std::endl;
								std::cout << byte1 << std::endl;
								std::cout << byte2 << std::endl;
								std::cout << std::endl;
								
								/// Print out as the number value
								std::cout << "Print out as the number value" << std::endl;
								std::cout << static_cast<unsigned int>(byte1) << std::endl;
								std::cout << static_cast<unsigned int>(byte2) << std::endl;
								std::cout << std::endl;
								
								/// Make and print out as bitset (bit by bit)
								std::cout << "Make and print out as bitset (bit by bit)" << std::endl;
								std::bitset<8> byte1_bitset(byte1);
								std::bitset<8> byte2_bitset(byte2);
								std::cout << byte1_bitset << std::endl;
								std::cout << byte2_bitset << std::endl;
								
								return 0;
							}
						\end{lstlisting}
					\end{minipage}
					
					\begin{minipage}{\linewidth}
						Gives the following output: \\
						-------------------------------------------------------------------------- \\
						The char values in question are 128 and 64 respectively. \\
						\\
						Print out as a char \\
						Ã‡ \\
						@ \\
						\\
						Print out as the number value \\
						128 \\
						64 \\
						\\
						Make and print out as bitset (bit by bit) \\
						10000000 \\
						01000000 \\
						-------------------------------------------------------------------------- \\
					\end{minipage}
				% End of subsubsection
				
				\subsubsection{Example code of example}
				\begin{minipage}{\linewidth}
					\begin{lstlisting}
						#include "stdafx.h"	// Because Visual Studio
						#include <iostream>
						#include <bitset>	// For making char into a bitset
						
						
						void print(char character, const std::string& input);
						
						
						int main()
						{
							unsigned char byte1 = 128;
							unsigned char byte2 = 64;
							unsigned char byte3;
							
							
							print(byte1, "byte1:\t128");
							print(byte2, "byt2:\t64");
							
							std::cout << std::endl;
							
							print(~byte1, "~byte1");
							print(~~byte1, "~~byte1");
							print(byte1 & byte2, "byte1 & byte2 \t- Bitwise AND");
							print(byte1 | byte2, "byte1 | byte2 \t- Bitwise OR");
							print(byte1 >> 2, "byte1 >> 2");
							print(byte2 << 1, "byte2 << 1");
							print(byte1 ^byte2, "byte1 ^byte2 \t- Exclusive OR");
							
							std::cout << std::endl;
							
							signed char b = 138;
							signed char br;
							print(b, "signed char b = 138");
							print(br = b >> 2, "br = b >> 2");
							
							return 0;
						}
						
							void print(char character, const std::string& inputText)
							{
							std::bitset<8> charAsBitset(character);
							unsigned int charAsInt = static_cast<unsigned int>(character);
							std::cout << charAsBitset << "\t" << inputText << std::endl;
						}
					\end{lstlisting}
				\end{minipage}
				
				\begin{minipage}{\linewidth}
					Gives the following output: \\
					-------------------------------------------------------------------------- \\
					10000000\hspace{10mm}        byte1: 128 \\
					01000000\hspace{10mm}        byte2:  64 \\
					\\
					01111111\hspace{10mm}        $\sim$byte1 \\
					10000000\hspace{10mm}        $\sim$$\sim$byte1 \\
					00000000\hspace{10mm}        byte1 \& byte2	- Bitwise AND \\
					11000000\hspace{10mm}        byte1 | byte2	- Bitwise OR \\
					00100000\hspace{10mm}        byte1 $>>$ 2 \\
					10000000\hspace{10mm}        byte2 $<<$ 1 \\
					11000000\hspace{10mm}        byte1 \^byte2	- Exclusive OR \\
					\\
					10001010\hspace{10mm}        signed char b = 138 \\
					11100010\hspace{10mm}        br = b $>>$ 2 \\
					-------------------------------------------------------------------------- \\
				\end{minipage}
				% End of subsubsection
			% End of subsection
			\\ \\
			
			\subsection{Task 5}
			Task 5 - Bitwise operations \\
			
			\begin{itemize}
				\item Make a program that registers decisions in some central questions in the election.
				\item The decisions will be stored in an unsigned char, and you are to use bitwise operators to store them.
				\begin{itemize}
					\item The EU decision in the first bit (YES has the value 1, NO has the value 0).
					\item Money support in the second bit (YES has the value 2, NO has the value 0).
					\item More privatization in the third bit (YES has the value 4, NO has the value 0).
				\end{itemize}
				\item If I am against the EU, but for money support and privatization, then the stored number should be 6.
				\item Make a char "opinions" to include these decisions.
				\item Register decisions by moving a 1 or a 0 to correct bit in "opinions", by using $<<$ and $>>$.
				\item Write out the decisions, one by one, by removing the non-relevant bits in "opinion".
			\end{itemize}
			
			
			\begin{minipage}{\linewidth}
				The solution code for this task:
				\begin{lstlisting}
					
				\end{lstlisting}
			\end{minipage}
			\\ \\
			% End of subsection
		% End of section
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		\iffalse
		
		
		\subsubsection{Task 5}
		Task 5 - Bitwise operations \\
		
		\begin{itemize}
			\item 
			\item 
			\item 
			\item 
			\item 
			\item 
			\item 
		\end{itemize}
		
		
		\begin{minipage}{\linewidth}
			The solution code for this task:
			\begin{lstlisting}
			
			\end{lstlisting}
		\end{minipage}
		\\ \\
		% End of subsubsection
		
		
		\begin{minipage}{\linewidth}
			Text
			\begin{lstlisting}
				
			\end{lstlisting}
		\end{minipage}
		\\ \\
		
		
		
		\begin{minipage}{0.95\linewidth}
			\begin{center}
				\begin{lstlisting}
				
				\end{lstlisting}
			\end{center}
		\end{minipage}
		
		\begin{minipage}{\linewidth}
			\begin{lstlisting}
				enum DayNumber {
					Monday, 	Tuesday,
					Wednesday, 	Thursday,
					Friday, 	Saturday,
					Sunday
				}
			\end{lstlisting}
		\end{minipage}
		
		is practically equivalent with
		
		\begin{minipage}{\linewidth}
			\begin{lstlisting}
				const int Monday	= 0;
				const int Tuesday	= 1;
				const int Wednesday	= 2;
				const int Thursday	= 3;
				const int Friday	= 4;
				const int Saturday	= 5;
				const int Sunday	= 6;
			\end{lstlisting}
		\end{minipage}
		\fi
	% End of Chapter 1

\end{document}
